package me.mini_bomba.streamchatmod;

import com.github.philippheuer.credentialmanager.domain.OAuth2Credential;
import com.github.twitch4j.TwitchClient;
import com.github.twitch4j.TwitchClientBuilder;
import com.github.twitch4j.chat.TwitchChat;
import com.github.twitch4j.chat.events.channel.ChannelMessageEvent;
import com.github.twitch4j.chat.events.channel.FollowEvent;
import com.sun.net.httpserver.HttpServer;
import me.mini_bomba.streamchatmod.commands.TwitchChatCommand;
import me.mini_bomba.streamchatmod.commands.TwitchCommand;
import net.minecraft.event.ClickEvent;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.ChatStyle;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.IChatComponent;
import net.minecraftforge.client.ClientCommandHandler;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.Mod.EventHandler;
import net.minecraftforge.fml.common.ModMetadata;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLModDisabledEvent;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.Nullable;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

@Mod(modid = StreamChatMod.MODID, version = StreamChatMod.VERSION, clientSideOnly = true)
public class StreamChatMod
{
    public static final String MODID = "streamchatmod";
    public static final String MODNAME = "StreamChat";
    public static final String VERSION = "1.2";
    private static final Logger LOGGER = LogManager.getLogger();
    public StreamConfig config;
    @Nullable
    public TwitchClient twitch = null;
    @Nullable
    public HttpServer httpServer = null;
    public int httpShutdownTimer = -1;
    public int eventSoundTimer = -1;
    public int loginMessageTimer = -1;

    private final StreamEvents events;

    public StreamChatMod() {
        events = new StreamEvents(this);
    }
    
    @EventHandler
    public void postInit(FMLPostInitializationEvent event)
    {
		startTwitch();
    }

    @EventHandler
    public void init(FMLInitializationEvent event) {
        ClientCommandHandler commandHandler = ClientCommandHandler.instance;
        commandHandler.registerCommand(new TwitchChatCommand(this));
        commandHandler.registerCommand(new TwitchCommand(this));

        MinecraftForge.EVENT_BUS.register(events);
    }

    @EventHandler
    public void preInit(FMLPreInitializationEvent event) {
        ModMetadata metadata = event.getModMetadata();
        metadata.autogenerated = false;
        metadata.name = MODNAME;
        metadata.authorList = Collections.singletonList("mini_bomba");
        metadata.description = "A Chat client for some streaming websites in minecraft beacuse yes.";
        metadata.version = VERSION;
        config = new StreamConfig(event.getSuggestedConfigurationFile());
    }

    @EventHandler
    public void stop(FMLModDisabledEvent event) {
        stopTwitch();
        config.saveIfChanged();
    }

    public void startTwitch() {
        if (twitch != null || !config.twitchEnabled.getBoolean()) return;
        String token = config.twitchToken.getString();
        if (token.equals("")) return;
        OAuth2Credential credential = new OAuth2Credential("twitch", token);
        twitch = TwitchClientBuilder.builder()
                .withDefaultAuthToken(credential)
                .withEnableChat(true)
                .withChatAccount(credential)
                .withEnableHelix(true)
                .build();
        twitch.getEventManager().onEvent(ChannelMessageEvent.class, this::onTwitchMessage);
        twitch.getEventManager().onEvent(FollowEvent.class, this::onTwitchFollow);
        TwitchChat chat = twitch.getChat();
        chat.connect();
        List<String> channels = Arrays.asList(config.twitchChannels.getStringList());
        for (String channel : chat.getChannels()) {
            if (!channels.contains(channel)) chat.leaveChannel(channel);
        }
        for (String channel : channels) {
            chat.joinChannel(channel);
        }
        if (config.followEventEnabled.getBoolean()) twitch.getClientHelper().enableFollowEventListener(channels);
    }

    private void onTwitchMessage(ChannelMessageEvent event) {
        boolean showChannel = config.forceShowChannelName.getBoolean() ||(twitch != null && twitch.getChat().getChannels().size() > 1);
        IChatComponent component = new ChatComponentText(EnumChatFormatting.DARK_PURPLE+"[TWITCH"+(showChannel ? "/"+event.getChannel().getName() : "")+"]"+EnumChatFormatting.WHITE+" <"+event.getUser().getName()+"> "+event.getMessage());
        ChatStyle style = new ChatStyle().setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/twitch delete " + event.getChannel().getName() + " " + event.getMessageEvent().getMessageId().orElse("")));
        component.setChatStyle(style);
        StreamUtils.addMessage(component);
        if (this.config.playSoundOnMessage.getBoolean()) StreamUtils.playSound("note.pling", (float) config.messageSoundVolume.getDouble(), 1.25f);
    }

    private void onTwitchFollow(FollowEvent event) {
        StreamUtils.addMessage(EnumChatFormatting.DARK_PURPLE+"[TWITCH] " + EnumChatFormatting.AQUA + EnumChatFormatting.BOLD + event.getUser().getName() + EnumChatFormatting.DARK_GREEN + " is now following " + EnumChatFormatting.AQUA + EnumChatFormatting.BOLD + event.getChannel().getName() + EnumChatFormatting.DARK_GREEN + "!");
        if (this.config.playSoundOnFollow.getBoolean()) eventSoundTimer = 0;
    }

    public void printTwitchStatus() {
        printTwitchStatus(false);
    }

    public void printTwitchStatus(boolean includePrefix) {
        String prefix = includePrefix ?  EnumChatFormatting.DARK_PURPLE+"[TWITCH] " : "";
        if (config.twitchEnabled.getBoolean() && twitch != null) {
            String channel = config.twitchSelectedChannel.getString();
            StreamUtils.addMessages(new String[] {
                    prefix + EnumChatFormatting.GRAY + "Twitch Chat status: " + EnumChatFormatting.GREEN + "Enabled",
                    prefix + EnumChatFormatting.GRAY + "Channels joined: " + EnumChatFormatting.AQUA + EnumChatFormatting.BOLD + twitch.getChat().getChannels().size(),
                    prefix + EnumChatFormatting.GRAY + "Selected channel: " +  (channel.length() > 0 ? "" + EnumChatFormatting.AQUA + EnumChatFormatting.BOLD + channel : EnumChatFormatting.RED + "None")
            });
        } else {
            StreamUtils.addMessage(prefix + EnumChatFormatting.GRAY + "Twitch Chat status: " + EnumChatFormatting.RED + "Disabled");
        }
    }

    public void stopTwitch() {
        if (twitch == null) return;
        TwitchChat chat = twitch.getChat();
        for (String channel : chat.getChannels()) {
            chat.leaveChannel(channel);
        }
        twitch.close();
        this.twitch = null;
    }
}
