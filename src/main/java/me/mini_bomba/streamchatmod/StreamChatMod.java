package me.mini_bomba.streamchatmod;

import com.github.philippheuer.credentialmanager.domain.OAuth2Credential;
import com.github.twitch4j.TwitchClient;
import com.github.twitch4j.TwitchClientBuilder;
import com.github.twitch4j.chat.TwitchChat;
import com.github.twitch4j.chat.events.channel.ChannelMessageEvent;
import com.github.twitch4j.chat.events.channel.FollowEvent;
import com.sun.net.httpserver.HttpServer;
import me.mini_bomba.streamchatmod.commands.TwitchChatCommand;
import me.mini_bomba.streamchatmod.commands.TwitchCommand;
import me.mini_bomba.streamchatmod.runnables.TwitchAsyncClientAction;
import me.mini_bomba.streamchatmod.runnables.TwitchFollowSoundScheduler;
import me.mini_bomba.streamchatmod.runnables.TwitchMessageHandler;
import me.mini_bomba.streamchatmod.runnables.UpdateChecker;
import net.minecraft.client.Minecraft;
import net.minecraft.event.ClickEvent;
import net.minecraft.event.HoverEvent;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.ChatStyle;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.IChatComponent;
import net.minecraftforge.client.ClientCommandHandler;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.Mod.EventHandler;
import net.minecraftforge.fml.common.ModMetadata;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLModDisabledEvent;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.Nullable;

import java.util.*;

@Mod(modid = StreamChatMod.MODID, version = StreamChatMod.VERSION, clientSideOnly = true)
public class StreamChatMod
{
    public static final String MODID = "streamchatmod";
    public static final String MODNAME = "StreamChatMod";
    public static final String VERSION = "@VERSION@";
    public static final String GIT_HASH = "@GIT_HASH@";
    public static final boolean PRERELEASE = "@PRERELEASE@"=="true";
    private static final Logger LOGGER = LogManager.getLogger();
    public StreamConfig config;
    @Nullable
    public String latestVersion = null;
    // LatestCommit is set only on prerelease builds
    @Nullable
    public StreamUtils.GitCommit latestCommit = null;
    @Nullable
    public TwitchClient twitch = null;
    @Nullable
    public TwitchClient twitchSender = null;
    @Nullable
    public HttpServer httpServer = null;
    public Thread httpShutdownScheduler = null;
    public int loginMessageTimer = -1;

    // Thread reference for running async Twitch client action, such as starting or stopping.
    public Thread twitchAsyncAction;

    public Thread updateCheckerThread;

    private final StreamEvents events;

    public StreamChatMod() {
        events = new StreamEvents(this);
    }
    
    @EventHandler
    public void postInit(FMLPostInitializationEvent event)
    {
        LOGGER.info("Checking for updates...");
        latestVersion = StreamUtils.getLatestVersion();
        if (PRERELEASE) {
            latestCommit = StreamUtils.getLatestCommit();
        }
        if ((latestVersion != null && !latestVersion.equals(VERSION)) || (latestCommit != null && !latestCommit.shortHash.equals(GIT_HASH)))
            LOGGER.warn("New version available: " + latestVersion + (latestCommit != null ? "@" + latestCommit.shortHash : "") + "!");
        else
            LOGGER.info("Mod is up to date!");
		startTwitch();
		if (config.updateCheckerEnabled.getBoolean()) startUpdateChecker();
    }

    @EventHandler
    public void init(FMLInitializationEvent event) {
        ClientCommandHandler commandHandler = ClientCommandHandler.instance;
        commandHandler.registerCommand(new TwitchChatCommand(this));
        commandHandler.registerCommand(new TwitchCommand(this));

        MinecraftForge.EVENT_BUS.register(events);
    }

    @EventHandler
    public void preInit(FMLPreInitializationEvent event) {
        ModMetadata metadata = event.getModMetadata();
        metadata.autogenerated = false;
        metadata.name = MODNAME;
        metadata.authorList = Collections.singletonList("mini_bomba");
        metadata.description = "A Chat client for Twitch in minecraft because yes";
        metadata.url = "https://github.com/mini-bomba/StreamChatMod";
        if (PRERELEASE) {
            metadata.version = GIT_HASH;
            metadata.description += "\n\nYou are running SCM prerelease built from git commit " + GIT_HASH;
        } else {
            metadata.version = VERSION;
            metadata.description += "\n\nYou are running SCM release version " + VERSION + " built from git commit " + GIT_HASH;
        }
        config = new StreamConfig(event.getSuggestedConfigurationFile());
    }

    @EventHandler
    public void stop(FMLModDisabledEvent event) {
        stopUpdateChecker();
        stopTwitch();
        config.saveIfChanged();
    }

    public void startUpdateChecker() {
        if (updateCheckerThread == null) {
            updateCheckerThread = new Thread(new UpdateChecker(this));
            updateCheckerThread.start();
        }
    }

    public void stopUpdateChecker() {
        if (updateCheckerThread != null)
            if (updateCheckerThread.isAlive())
                updateCheckerThread.interrupt();
            else
                updateCheckerThread = null;
    }

    private void asyncTwitchAction(Runnable action) throws ConcurrentModificationException {
        if (twitchAsyncAction != null) throw new ConcurrentModificationException("An async action is already running!");
        twitchAsyncAction = new Thread(new TwitchAsyncClientAction(this, action));
        twitchAsyncAction.start();
    }

    public void asyncStartTwitch() throws ConcurrentModificationException {
        asyncTwitchAction(() -> {
            if (startTwitch())
                StreamUtils.queueAddMessage(EnumChatFormatting.GREEN+"Enabled the Twitch Chat!");
            else
                StreamUtils.queueAddMessage(EnumChatFormatting.RED+"Could not start the Twitch client, the token may be invalid!");
        });
    }

    public void asyncStopTwitch() throws ConcurrentModificationException {
        asyncTwitchAction(() -> {
            stopTwitch();
            StreamUtils.queueAddMessage(EnumChatFormatting.GREEN+"Disabled the Twitch Chat!");
        });
    }

    public void asyncRestartTwitch() throws ConcurrentModificationException {
        asyncTwitchAction(() -> {
            stopTwitch();
            if (startTwitch())
                StreamUtils.queueAddMessage(EnumChatFormatting.GREEN+"Restarted the Twitch Chat!");
            else
                StreamUtils.queueAddMessage(EnumChatFormatting.RED+"Could not restart the Twitch client, the token may be invalid!");
        });
    }

    public void asyncRevokeTwitchToken() throws ConcurrentModificationException {
        asyncTwitchAction(() -> {
            stopTwitch();
            config.twitchEnabled.set(false);
            boolean revoked = config.revokeTwitchToken();
            if (revoked) {
                config.setTwitchToken("");
                StreamUtils.queueAddMessage(EnumChatFormatting.GREEN + "The token has been revoked!");
            } else {
                StreamUtils.queueAddMessage(EnumChatFormatting.RED + "Could not revoke the token! It may be invalid, or the request could not have been sent!");
            }
            config.saveIfChanged();
        });
    }

    public void asyncJoinTwitchChannel(String channel) throws ConcurrentModificationException {
        asyncTwitchAction(() -> {
            if (twitch == null) { StreamUtils.queueAddMessage(EnumChatFormatting.RED + "Twitch chat is not enabled!"); return; }
            TwitchChat chat = twitch.getChat();
            if (chat == null) { StreamUtils.queueAddMessage(EnumChatFormatting.RED + "Twitch chat is not enabled!"); return; }
            chat.joinChannel(channel);
            if (!chat.isChannelJoined(channel)) { StreamUtils.queueAddMessage(EnumChatFormatting.RED + "Something went wrong: Could not join the channel."); return; }
            if (config.followEventEnabled.getBoolean()) twitch.getClientHelper().enableFollowEventListener(channel);
            String[] channelArray = config.twitchChannels.getStringList();
            ArrayList<String> channelList = new ArrayList<>(Arrays.asList(channelArray));
            channelList.add(channel);
            config.twitchChannels.set(channelList.toArray(new String[0]));
            config.saveIfChanged();
            StreamUtils.queueAddMessage(EnumChatFormatting.GREEN+"Joined "+channel+"'s chat!");
        });
    }

    public void asyncLeaveTwitchChannel(String channel) throws ConcurrentModificationException {
        asyncTwitchAction(() -> {
            if (twitch == null) { StreamUtils.queueAddMessage(EnumChatFormatting.RED + "Twitch chat is not enabled!"); return; }
            TwitchChat chat = twitch.getChat();
            if (chat == null) { StreamUtils.queueAddMessage(EnumChatFormatting.RED + "Twitch chat is not enabled!"); return; }
            chat.leaveChannel(channel);
            if (chat.isChannelJoined(channel)) { StreamUtils.queueAddMessage(EnumChatFormatting.RED + "Something went wrong: Could not leave the channel."); return; }
            if (config.followEventEnabled.getBoolean()) twitch.getClientHelper().disableFollowEventListener(channel);
            String[] channelArray = config.twitchChannels.getStringList();
            ArrayList<String> channelList = new ArrayList<>(Arrays.asList(channelArray));
            channelList.remove(channel);
            config.twitchChannels.set(channelList.toArray(new String[0]));
            config.saveIfChanged();
            StreamUtils.queueAddMessage(EnumChatFormatting.GREEN+"Left "+channel+"'s chat!");
        });
    }

    public void asyncUpdateFollowEvents() throws ConcurrentModificationException {
        asyncTwitchAction(() -> {
            if (twitch == null) { StreamUtils.queueAddMessage(EnumChatFormatting.RED + "Twitch chat is not enabled!"); return; }
            List<String> channels = Arrays.asList(config.twitchChannels.getStringList());
            if (config.followEventEnabled.getBoolean())
                twitch.getClientHelper().enableFollowEventListener(channels);
            else
                twitch.getClientHelper().disableFollowEventListener(channels);
            StreamUtils.queueAddMessage(EnumChatFormatting.GREEN+"Follow event listeners updated!");
        });
    }

    public boolean startTwitch() {
        if (twitch != null || !config.twitchEnabled.getBoolean()) return false;
        String token = config.twitchToken.getString();
        if (token.equals("")) return false;
        try {
            // Build the main TwitchClient
            OAuth2Credential credential = new OAuth2Credential("twitch", token);
            twitch = TwitchClientBuilder.builder()
                    .withDefaultAuthToken(credential)
                    .withEnableChat(true)
                    .withChatAccount(credential)
                    .withEnableHelix(true)
                    .build();
            twitch.getEventManager().onEvent(ChannelMessageEvent.class, this::onTwitchMessage);
            twitch.getEventManager().onEvent(FollowEvent.class, this::onTwitchFollow);
            TwitchChat chat = twitch.getChat();
            chat.connect();
            List<String> channels = Arrays.asList(config.twitchChannels.getStringList());
            for (String channel : chat.getChannels()) {
                if (!channels.contains(channel)) chat.leaveChannel(channel);
            }
            for (String channel : channels) {
                chat.joinChannel(channel);
            }
            if (config.followEventEnabled.getBoolean()) twitch.getClientHelper().enableFollowEventListener(channels);
            // Build the TwitchClient for sending messages (so they can be seen in-game)
            twitchSender = TwitchClientBuilder.builder()
                    .withDefaultAuthToken(credential)
                    .withEnableChat(true)
                    .withChatAccount(credential)
                    .build();
            TwitchChat senderChat = twitchSender.getChat();
            for (String channel : senderChat.getChannels())
                senderChat.leaveChannel(channel);
            return true;
        } catch (Exception e) {
            LOGGER.error("Failed to start Twitch client");
            e.printStackTrace();
            twitch = null;
            return false;
        }
    }

    private void onTwitchMessage(ChannelMessageEvent event) {
        Minecraft.getMinecraft().addScheduledTask(new TwitchMessageHandler(this, event));
    }

    private void onTwitchFollow(FollowEvent event) {
        Minecraft.getMinecraft().addScheduledTask(() -> StreamUtils.addMessage(EnumChatFormatting.DARK_PURPLE+"[TWITCH] " + EnumChatFormatting.AQUA + EnumChatFormatting.BOLD + event.getUser().getName() + EnumChatFormatting.DARK_GREEN + " is now following " + EnumChatFormatting.AQUA + EnumChatFormatting.BOLD + event.getChannel().getName() + EnumChatFormatting.DARK_GREEN + "!"));
        if (this.config.playSoundOnFollow.getBoolean()) new Thread(new TwitchFollowSoundScheduler(this)).start();
    }

    public void printTwitchStatus() {
        printTwitchStatus(false);
    }

    public void printTwitchStatus(boolean includePrefix) {
        String prefix = includePrefix ?  EnumChatFormatting.DARK_PURPLE+"[TWITCH] " : "";
        IChatComponent component = new ChatComponentText(prefix + EnumChatFormatting.GRAY + "Mod version: " + EnumChatFormatting.AQUA + EnumChatFormatting.BOLD + VERSION + (PRERELEASE ? EnumChatFormatting.GRAY + "@" + EnumChatFormatting.AQUA + GIT_HASH : "") + EnumChatFormatting.GRAY + " (" + (latestVersion == null || (PRERELEASE && latestCommit == null) ? EnumChatFormatting.RED + "Could not check latest version" : (latestVersion.equals(VERSION) && (!PRERELEASE || latestCommit.shortHash.equals(GIT_HASH)) ? EnumChatFormatting.GREEN + "Latest version" : EnumChatFormatting.GOLD + "Update available: " + latestVersion + (PRERELEASE ? "@" + latestCommit.shortHash : "")) ) + EnumChatFormatting.GRAY + ")");
        IChatComponent commitMessage = null;
        if (latestVersion != null && !latestVersion.equals(VERSION) || (PRERELEASE && latestCommit != null && !latestCommit.shortHash.equals(GIT_HASH))) {
            if (PRERELEASE && latestCommit != null) commitMessage = new ChatComponentText(prefix + EnumChatFormatting.GRAY + "Latest commit message: " + EnumChatFormatting.AQUA + latestCommit.shortMessage);
            ChatStyle style = new ChatStyle().setChatClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, "https://github.com/mini-bomba/StreamChatMod/releases"));
            style.setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ChatComponentText(EnumChatFormatting.GREEN + "Click here to see mod releases on GitHub!")));
            component.setChatStyle(style);
            if (commitMessage != null) commitMessage.setChatStyle(style);
        }
        StreamUtils.addMessage(component);
        if (commitMessage != null) StreamUtils.addMessage(commitMessage);
        if (config.twitchEnabled.getBoolean() && twitch != null) {
            String channel = config.twitchSelectedChannel.getString();
            StreamUtils.addMessages(new String[] {
                    prefix + EnumChatFormatting.GRAY + "Twitch Chat status: " + EnumChatFormatting.GREEN + "Enabled",
                    prefix + EnumChatFormatting.GRAY + "Channels joined: " + EnumChatFormatting.AQUA + EnumChatFormatting.BOLD + twitch.getChat().getChannels().size(),
                    prefix + EnumChatFormatting.GRAY + "Selected channel: " +  (channel.length() > 0 ? "" + EnumChatFormatting.AQUA + EnumChatFormatting.BOLD + channel : EnumChatFormatting.RED + "None"),
                    prefix + EnumChatFormatting.GRAY + "Formatted messages: " + (config.allowFormatting.getBoolean() ? (config.subOnlyFormatting.getBoolean() ? EnumChatFormatting.GOLD + "Subscriber+ only" : EnumChatFormatting.GREEN + "Enabled") : EnumChatFormatting.RED + "Disabled"),
                    prefix + EnumChatFormatting.GRAY + "Minecraft chat mode: " + (config.twitchMessageRedirectEnabled.getBoolean() ? EnumChatFormatting.DARK_PURPLE + "Redirect to selected Twitch channel" : EnumChatFormatting.GREEN + "Send to Minecraft server") + EnumChatFormatting.GRAY + " (/twitch mode)"
            });
            if (config.twitchMessageRedirectEnabled.getBoolean()) {
                String minecraftPrefix = config.minecraftChatPrefix.getString();
                StreamUtils.addMessage(prefix + EnumChatFormatting.GRAY + "Minecraft chat prefix: " + (minecraftPrefix.length() == 0 ? EnumChatFormatting.RED + "Disabled!" : EnumChatFormatting.AQUA + minecraftPrefix));
            }
        } else {
            StreamUtils.addMessage(prefix + EnumChatFormatting.GRAY + "Twitch Chat status: " + EnumChatFormatting.RED + "Disabled" + (config.twitchEnabled.getBoolean() && config.twitchToken.getString().length() > 0 ? ", the token may be invalid!" : ""));
        }
    }

    public void stopTwitch() {
        if (twitch != null) {
            TwitchClient twitchClient = this.twitch;
            this.twitch = null;
            TwitchChat chat = twitchClient.getChat();
            for (String channel : chat.getChannels()) {
                chat.leaveChannel(channel);
            }
            twitchClient.getClientHelper().disableFollowEventListener(Arrays.asList(config.twitchChannels.getStringList()));
            twitchClient.close();
        }
        if (twitchSender != null) {
            TwitchClient twitchClient = this.twitchSender;
            this.twitchSender = null;
            twitchClient.close();
        }
    }
}
